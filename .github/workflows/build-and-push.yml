name: Build and Push HappyHeadlines Images

on:
  push:
    branches: [main]

jobs:
  # Step 1: Run unit tests
  unit-tests:
    name: üß™ Unit Tests
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '9.0.x'

      - name: Restore NuGet packages
        run: dotnet restore HappyHeadlines.sln

      - name: Build solution
        run: dotnet build HappyHeadlines.sln -c Release --no-restore

      - name: Run unit tests
        run: dotnet test HappyHeadlines.sln -c Release --no-build --verbosity normal

  # Step 2: Build Docker images
  build:
    name: üî® Build Docker Images
    runs-on: ubuntu-latest
    needs: unit-tests
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build all service images
        run: |
          declare -A MAP=(
            ["ArticleService"]="article-service"
            ["CommentService"]="comment-service"
            ["DraftService"]="draft-service"
            ["ProfanityService"]="profanity-service"
            ["PublisherService"]="publisher-service"
            ["NewsletterService"]="newsletter-service"
            ["Monitoring"]="monitoring-service"
            ["SubscriberService"]="subscriber-service"
          )

          for DIR in "${!MAP[@]}"; do
            IMAGE="${MAP[$DIR]}"
            echo "üî® Building $DIR ‚Üí $IMAGE:latest"
            docker build -f "./$DIR/Dockerfile" -t "$IMAGE:latest" .
          done

          echo "‚úÖ All images built successfully"

      - name: Save Docker images as artifacts
        run: |
          mkdir -p /tmp/images
          docker save article-service:latest -o /tmp/images/article-service.tar
          docker save comment-service:latest -o /tmp/images/comment-service.tar
          docker save draft-service:latest -o /tmp/images/draft-service.tar
          docker save profanity-service:latest -o /tmp/images/profanity-service.tar
          docker save publisher-service:latest -o /tmp/images/publisher-service.tar
          docker save newsletter-service:latest -o /tmp/images/newsletter-service.tar
          docker save monitoring-service:latest -o /tmp/images/monitoring-service.tar
          docker save subscriber-service:latest -o /tmp/images/subscriber-service.tar

      - name: Upload Docker images artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-images
          path: /tmp/images
          retention-days: 1

  # Step 3: Run integration tests
  integration-tests:
    name: üîó Integration Tests
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download Docker images artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-images
          path: /tmp/images

      - name: Load Docker images
        run: |
          for img in /tmp/images/*.tar; do
            echo "üì¶ Loading $(basename $img)..."
            docker load -i "$img"
          done
          echo "‚úÖ All images loaded"

      - name: Start all services
        run: |
          echo "üöÄ Starting all services with docker-compose..."
          docker compose -f docker-compose.yml up -d

          echo "‚è≥ Waiting for services to initialize (90 seconds)..."
          sleep 90

          echo "üìã Checking running containers..."
          docker compose -f docker-compose.yml ps

      - name: Wait for services to be healthy
        run: |
          echo "üîç Waiting for services to be ready..."
          
          BASE_URL="http://localhost"
          MAX_ATTEMPTS=30
          
          # Wait for ArticleService (port 8000)
          echo "Waiting for ArticleService..."
          for i in $(seq 1 $MAX_ATTEMPTS); do
            if curl -sf "${BASE_URL}:8000/api/Article?region=Europe" > /dev/null 2>&1; then
              echo "‚úÖ ArticleService is ready"
              break
            fi
            if [ $i -eq $MAX_ATTEMPTS ]; then
              echo "‚ùå ArticleService not ready after $MAX_ATTEMPTS attempts"
              docker compose -f docker-compose.yml logs article-service --tail=30
              exit 1
            fi
            echo "  Attempt $i/$MAX_ATTEMPTS - waiting 5s..."
            sleep 5
          done
          
          # Wait for PublisherService (port 8006)
          echo "Waiting for PublisherService..."
          for i in $(seq 1 $MAX_ATTEMPTS); do
            if curl -sf "${BASE_URL}:8006/api/Publisher" -X OPTIONS > /dev/null 2>&1 || curl -sf -o /dev/null -w "%{http_code}" "${BASE_URL}:8006/api/Publisher" 2>&1 | grep -qE "^[245]"; then
              echo "‚úÖ PublisherService is ready"
              break
            fi
            if [ $i -eq $MAX_ATTEMPTS ]; then
              echo "‚ùå PublisherService not ready after $MAX_ATTEMPTS attempts"
              docker compose -f docker-compose.yml logs publisher-service --tail=30
              exit 1
            fi
            echo "  Attempt $i/$MAX_ATTEMPTS - waiting 5s..."
            sleep 5
          done

      - name: Run integration tests
        run: |
          echo "üß™ Running integration tests..."
          
          REGION="Europe"
          BASE_URL="http://localhost"
          FAILED=0

          # Helper function to safely run curl (always returns 0 to shell)
          safe_curl() {
            local response
            local http_code
            local exit_code
            response=$(curl -s -w "\nHTTP_CODE:%{http_code}" "$@" 2>&1) || true
            exit_code=$?
            http_code=$(echo "$response" | grep "HTTP_CODE:" | cut -d':' -f2)
            body=$(echo "$response" | grep -v "HTTP_CODE:")
            echo "EXIT:$exit_code"
            echo "HTTP:$http_code"
            echo "BODY:$body"
          }

          # Test 1: Publish an article via PublisherService
          echo "üìù Test 1: Publishing article via PublisherService..."
          ARTICLE_JSON='{"Title":"CI Integration Test Article","Content":"This article was created by GitHub Actions integration test.","Author":"GitHub Actions","Region":"'$REGION'"}'
          
          RESULT=$(safe_curl -X POST "${BASE_URL}:8006/api/Publisher" \
              -H "Content-Type: application/json" \
              -d "$ARTICLE_JSON")
          CURL_EXIT=$(echo "$RESULT" | grep "EXIT:" | cut -d':' -f2)
          HTTP_CODE=$(echo "$RESULT" | grep "HTTP:" | cut -d':' -f2)
          
          if [ "$CURL_EXIT" = "0" ] && [[ "$HTTP_CODE" =~ ^2 ]]; then
            echo "‚úÖ Article published successfully"
          else
            echo "‚ùå Failed to publish article (curl exit: $CURL_EXIT, HTTP: $HTTP_CODE)"
            FAILED=1
          fi

          # Wait for message queue consumption
          echo "‚è≥ Waiting for ArticleService to consume message (15 seconds)..."
          sleep 15

          # Test 2: Retrieve articles from ArticleService (port 8000)
          echo "üìñ Test 2: Retrieving articles from ArticleService..."
          RESULT=$(safe_curl "${BASE_URL}:8000/api/Article?region=$REGION")
          CURL_EXIT=$(echo "$RESULT" | grep "EXIT:" | cut -d':' -f2)
          HTTP_CODE=$(echo "$RESULT" | grep "HTTP:" | cut -d':' -f2)
          
          if [ "$CURL_EXIT" = "0" ] && [[ "$HTTP_CODE" =~ ^2 ]]; then
            echo "‚úÖ Articles retrieved successfully"
          else
            echo "‚ùå Failed to retrieve articles (curl exit: $CURL_EXIT, HTTP: $HTTP_CODE)"
            FAILED=1
          fi

          # Test 3: Test ProfanityService (GET /api/Profanity)
          echo "üîç Test 3: Testing ProfanityService..."
          RESULT=$(safe_curl "${BASE_URL}:8003/api/Profanity")
          CURL_EXIT=$(echo "$RESULT" | grep "EXIT:" | cut -d':' -f2)
          HTTP_CODE=$(echo "$RESULT" | grep "HTTP:" | cut -d':' -f2)
          
          if [ "$CURL_EXIT" = "0" ] && [[ "$HTTP_CODE" =~ ^2 ]]; then
            echo "‚úÖ ProfanityService responding"
          else
            echo "‚ö†Ô∏è ProfanityService issue (curl exit: $CURL_EXIT, HTTP: $HTTP_CODE) - non-critical"
          fi

          # Test 4: Test SubscriberService
          echo "üë§ Test 4: Testing SubscriberService..."
          SUBSCRIBER_JSON='{"Email":"citest@happyheadlines.com","Name":"CI Test User"}'
          RESULT=$(safe_curl -X POST "${BASE_URL}:8007/api/Subscriber" \
              -H "Content-Type: application/json" \
              -d "$SUBSCRIBER_JSON")
          CURL_EXIT=$(echo "$RESULT" | grep "EXIT:" | cut -d':' -f2)
          HTTP_CODE=$(echo "$RESULT" | grep "HTTP:" | cut -d':' -f2)
          
          if [ "$CURL_EXIT" = "0" ] && [[ "$HTTP_CODE" =~ ^2 ]]; then
            echo "‚úÖ SubscriberService responding"
          else
            echo "‚ö†Ô∏è SubscriberService issue (curl exit: $CURL_EXIT, HTTP: $HTTP_CODE) - non-critical"
          fi

          # Test 5: Test Monitoring service
          echo "üìä Test 5: Testing Monitoring service..."
          RESULT=$(safe_curl "${BASE_URL}:8085/api/Monitor/metrics")
          CURL_EXIT=$(echo "$RESULT" | grep "EXIT:" | cut -d':' -f2)
          HTTP_CODE=$(echo "$RESULT" | grep "HTTP:" | cut -d':' -f2)
          
          if [ "$CURL_EXIT" = "0" ] && [[ "$HTTP_CODE" =~ ^2 ]]; then
            echo "‚úÖ Monitoring service responding"
          else
            echo "‚ö†Ô∏è Monitoring service issue (curl exit: $CURL_EXIT, HTTP: $HTTP_CODE) - non-critical"
          fi

          # Final result
          if [ $FAILED -eq 1 ]; then
            echo "‚ùå Critical integration tests failed"
            exit 1
          fi

          echo "‚úÖ All critical integration tests passed!"

      - name: Show service logs on failure
        if: failure()
        run: |
          echo "üìã Service logs:"
          docker compose -f docker-compose.yml logs --tail=50

      - name: Stop services
        if: always()
        run: |
          echo "üßπ Stopping services..."
          docker compose -f docker-compose.yml down

  # Step 4: Push to GitHub Container Registry
  push:
    name: üöÄ Push to Registry
    runs-on: ubuntu-latest
    needs: integration-tests
    permissions:
      contents: read
      packages: write
    steps:
      - name: Download Docker images artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-images
          path: /tmp/images

      - name: Load Docker images
        run: |
          for img in /tmp/images/*.tar; do
            echo "üì¶ Loading $(basename $img)..."
            docker load -i "$img"
          done

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Tag and push images
        run: |
          declare -A MAP=(
            ["article-service"]="article-service"
            ["comment-service"]="comment-service"
            ["draft-service"]="draft-service"
            ["profanity-service"]="profanity-service"
            ["publisher-service"]="publisher-service"
            ["newsletter-service"]="newsletter-service"
            ["monitoring-service"]="monitoring-service"
            ["subscriber-service"]="subscriber-service"
          )

          OWNER=${{ github.repository_owner }}

          for IMAGE in "${!MAP[@]}"; do
            LOCAL_TAG="$IMAGE:latest"
            REMOTE_TAG="ghcr.io/${OWNER}/${IMAGE}:latest"
            
            echo "üè∑Ô∏è Tagging $LOCAL_TAG ‚Üí $REMOTE_TAG"
            docker tag "$LOCAL_TAG" "$REMOTE_TAG"
            
            echo "üöÄ Pushing $REMOTE_TAG"
            docker push "$REMOTE_TAG"
          done

          echo "‚úÖ All images pushed successfully"
